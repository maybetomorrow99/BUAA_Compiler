#include "parser.h"

using namespace std;

void Parser::getToken() {
	if (tokens.size()) {
		curToken = tokens.front();
		tokens.pop();
	}
	else {
		curToken = lexer.getToken();
	}
}

void Parser::pushToken(Token t) {
	tmpTokens.push(t);
}

void Parser::clearToken() {
	while (!tmpTokens.empty()) tmpTokens.pop();
}

void Parser::retract() {
	tokens = tmpTokens;
	clearToken();
}

//除了主程序外，每个子程序段的最后一定是getToken()
/*
<程序>    :: = ［<常量说明>］［<变量说明>］{ <有返回值函数定义> | <无返回值函数定义> }<主函数>
<常量说明> first = {const}
<变量说明> first = {int, char}
<有返回值函数定义> first = {int, char}
<无返回值函数定义> first = {void}
<主函数> first ={void}
*/
void Parser::program() {
	getToken();

	//常量说明
	if (curToken.type == CONST) {
		constDecl();
	}

	//变量说明或有返回值函数定义
	if (curToken.type == INT || curToken.type == CHAR) {
		pushToken(curToken);
		getToken();
		if (curToken.type == ID) {
			pushToken(curToken);
			getToken();
			//变量说明，token回溯到标识符位置
			if (curToken.type == COMMA || curToken.type == SEMI || curToken.type == LBRK) {
				pushToken(curToken);
				retract();
				getToken();
				varDecl();
			}
			//有返回值函数定义，token回溯到标识符位置
			else if (curToken.type == LPAR || curToken.type == LBRA) {
				pushToken(curToken);	//此处不进行处理，进入下一步
				retract();
				getToken();
			}
		}
		else {
			error(UNKNOWN, lexer.lineNum);
		}
	}
	
	//{ <有返回值函数定义> | <无返回值函数定义> }
	while (curToken.type == INT || curToken.type == CHAR || curToken.type == VOID) {
		//有返回值函数
		if (curToken.type == INT || curToken.type == CHAR) {
			pushToken(curToken);
			getToken();
			if (curToken.type == ID) {
				pushToken(curToken);
				getToken();
				if (curToken.type == LPAR || curToken.type == LBRA) {
					pushToken(curToken);
					retract();
					getToken();
					funcWithVal();
				}
				else {
					//int f后没有括号
					error(0, lexer.lineNum);
				}
			}
			else {
				error(MISSING_IDEN, lexer.lineNum);
			}
		}
		//无返回值函数或main函数
		else {
			pushToken(curToken);
			getToken();
			//main函数，token回溯到void
			if (curToken.type == MAIN) {
				pushToken(curToken);
				retract();
				getToken();
				break;
			}
			//无返回值函数
			else if (curToken.type == ID) {
				pushToken(curToken);
				retract();
				getToken();
				funcWithNoVal();
			}
			else {
				error(MISSING_LEFT_PARENTHESIS, lexer.lineNum);
			}
		}
	}

	//main函数
	if (curToken.type == VOID) {
		pushToken(curToken);
		getToken();
		if (curToken.type == MAIN) {
			pushToken(curToken);
			retract();
			getToken();
			mainFunc();
		}
	}
	else {
		error(MISSING_MAIN, lexer.lineNum);
	}
	
	cout << setw(4) << left << lexer.lineNum<< "This is a program" << endl;
}

/*
<常量说明> ::=  const<常量定义>;{ const<常量定义>;}
*/
void Parser::constDecl() {
	if (curToken.type == CONST) {
		getToken();
		if (curToken.type == INT || curToken.type == CHAR) {
			constDef();

			if (curToken.type == SEMI) {

				getToken();
			}
			else {
				error(MISSING_SEMI, lexer.lineNum);
			}
		}
		
	}
	else {
		error(MISSING_CONS, lexer.lineNum);
	}
	while (curToken.type == CONST) {
		getToken();
		if (curToken.type == INT || curToken.type == CHAR) {
			constDef();
			if (curToken.type == SEMI) {
				getToken();
			}
			else {
				error(MISSING_SEMI, lexer.lineNum);
				break;
			}
		}
		else {
			error(UNKNOWN, lexer.lineNum);
		}
	}
	cout << setw(4) << left << lexer.lineNum<< "This is a constant declaration" << endl;
}

/*
<常量定义>   ::=   int<标识符>＝<整数>{,<标识符>＝<整数>}
				| char<标识符>＝<字符>{,<标识符>＝<字符>}
*/
void Parser::constDef() {
	if (curToken.type == INT) {
		getToken();
		if (curToken.type != ID) {
			error(MISSING_IDEN, lexer.lineNum);
		}

		getToken();
		if (curToken.type != EQU) {
			error(MISSING_EQUAL_SIGN, lexer.lineNum);
		}

		getToken();
		intNum();

		while (curToken.type == COMMA) {
			getToken();
			if (curToken.type != ID) {
				error(MISSING_IDEN, lexer.lineNum);
			}

			getToken();
			if (curToken.type != EQU) {
				error(MISSING_EQUAL_SIGN, lexer.lineNum);
			}

			getToken();
			intNum();
		}							
	}
	else if (curToken.type == CHAR) {

		getToken();
		if (curToken.type != ID) {
			//error
			error(MISSING_IDEN, lexer.lineNum);
		}

		getToken();
		if (curToken.type != EQU) {
			error(MISSING_EQUAL_SIGN, lexer.lineNum);
		}
		getToken();
		if (curToken.type != SIGCHAR) {
			error(MISSING_CHAR, lexer.lineNum);
		}

		getToken();
		while (curToken.type == COMMA) {
			getToken();
			if (curToken.type != ID) {
				//error
				error(MISSING_IDEN, lexer.lineNum);
			}

			getToken();
			if (curToken.type != EQU) {
				error(MISSING_EQUAL_SIGN, lexer.lineNum);
			}

			getToken();
			if (curToken.type != SIGCHAR) {
				error(MISSING_CHAR, lexer.lineNum);
			}

			getToken();
		}
	}
	else {
		//error
		error(MISSING_IDEN, lexer.lineNum);
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a constant definition" << endl;
}

/*
<变量说明>  ::= <变量定义>;{<变量定义>;}
*/
void Parser::varDecl() {
	varDef();
	if (curToken.type == SEMI) {
		getToken();
		while (curToken.type == INT || curToken.type == CHAR) {
			pushToken(curToken);
			getToken();
			if (curToken.type == ID) {
				pushToken(curToken);
				getToken();
				if (curToken.type == COMMA || curToken.type == SEMI || curToken.type == LBRK) {
					pushToken(curToken);
					retract();
					getToken();
					varDef();
					if (curToken.type == SEMI) {
						getToken();
					}
					else {
						error(MISSING_SEMI, lexer.lineNum);
					}
				}
				//有返回值函数定义，token回溯到标识符位置
				else if (curToken.type == LPAR || curToken.type == LBRA) {
					pushToken(curToken);	//此处不进行处理，进入下一步
					retract();
					getToken();
					break;
				}
			}
		}
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a variable declaration" << endl;
}

/*
<变量定义>  ::= <类型标识符>(<标识符>|<标识符>‘[’<无符号整数>‘]’){,(<标识符>|<标识符>‘[’<无符号整数>‘]’) } 
//<无符号整数>表示数组元素的个数，其值需大于0
*/
void Parser::varDef() {
	if (curToken.type == INT || curToken.type == CHAR) {
		getToken();
		if (curToken.type != ID) {
			error(MISSING_IDEN, lexer.lineNum);
		}
		getToken();
		if (curToken.type == LBRK) {
			getToken();
			if (curToken.type == NUM) {
				getToken();
				if (curToken.type == RBRK) {
					getToken();
				}
			}
		}

		while (curToken.type == COMMA) {
			getToken();
			if (curToken.type != ID) {
				//error
				error(MISSING_IDEN, lexer.lineNum);
			}
			getToken();
			if (curToken.type == LBRK) {
				getToken();
				if (curToken.type == NUM) {
					getToken();
					if (curToken.type == RBRK) {
						getToken();
					}
				}
			}
		}
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a variable definitions" << endl;
}

/*
<有返回值函数定义>  ::=  <声明头部>‘(’<参数表>‘)’ ‘{’<复合语句>‘}’|<声明头部>‘{’<复合语句>‘}’
<声明头部>   ::=  int<标识符>|char<标识符>
//第一种选择为有参数的情况，第二种选择为无参数的情况
*/
void Parser::funcWithVal() {
	//声明头部
	SymbolType type;
	string name;
	if (curToken.type == INT || curToken.type == CHAR) {

		if (curToken.type == INT)
			type = INTTP;
		else
			type = CHARTP;

		getToken();
		if (curToken.type == ID) {

			name = curToken.str;

			getToken();
		}
		else {
			error(MISSING_IDEN, lexer.lineNum);
		}
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}

	if (curToken.type == LPAR) {	//有参数
		getToken();
		paraTab();
		if (curToken.type != RPAR) {
			error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
		}
		getToken();
		if (curToken.type != LBRA) {
			error(MISSING_LEFT_BRACE, lexer.lineNum);
		}
		getToken();
		compState();
		if (curToken.type != RBRA) {
			error(MISSING_RIGHT_BRACE, lexer.lineNum);
		}

		symTab.insert(name, FUNCKD, type, 0, 1);

		getToken();
	}
	else if (curToken.type == LBRA) {	//无参数

		getToken();
		compState();
		if (curToken.type != RBRA) {
			error(MISSING_LEFT_BRACE, lexer.lineNum);
		}

		symTab.insert(name, FUNCKD, type, 0, 0);

		getToken();
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a function definition with return value" << endl;
}

/*
<无返回值函数定义>  ::= void<标识符>(’<参数表>‘)’‘{’<复合语句>‘}’| void<标识符>{’<复合语句>‘}’
//第一种选择为有参数的情况，第二种选择为无参数的情况
*/
void Parser::funcWithNoVal() {
	SymbolType type;
	string name;

	if (curToken.type != VOID) {
		error(UNKNOWN, lexer.lineNum);
	}

	type = VOIDTP;

	getToken();
	if (curToken.type != ID) {
		error(MISSING_IDEN, lexer.lineNum);
	}

	name = curToken.str;

	getToken();
	if (curToken.type == LPAR) {	//有参数
		getToken();
		paraTab();
		if (curToken.type != RPAR) {
			error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
		}
		getToken();
		if (curToken.type != LBRA) {
			error(MISSING_LEFT_BRACE, lexer.lineNum);
		}
		getToken();
		compState();
		if (curToken.type != RBRA) {
			error(MISSING_RIGHT_BRACE, lexer.lineNum);
		}

		symTab.insert(name, FUNCKD, type, 0, 1);

		getToken();
	}
	else if (curToken.type == LBRA) {	//无参数
		getToken();
		compState();
		if (curToken.type != RBRA) {
			error(MISSING_RIGHT_BRACE, lexer.lineNum);
		}

		symTab.insert(name, FUNCKD, type, 0, 0);

		getToken();
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a function definition without return value" << endl;
}

/*
<声明头部>   ::=  int<标识符>|char<标识符>
*/
void Parser::declHeader() {
	if (curToken.type == INT || curToken.type == CHAR) {
		getToken();
		if (curToken.type == ID) {
			getToken();
		}
		else {
			error(MISSING_IDEN, lexer.lineNum);
		}
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a declaration header" << endl;
}

/*
<主函数>    ::= void main‘(’‘)’ ‘{’<复合语句>‘}’
*/
void Parser::mainFunc() {
	if (curToken.type != VOID) {
		error(UNKNOWN, lexer.lineNum);
	}
	getToken();
	if (curToken.type != MAIN) {
		error(MISSING_MAIN, lexer.lineNum);
	}
	getToken();
	if (curToken.type != LPAR) {
		error(MISSING_LEFT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	if (curToken.type != RPAR) {
		error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	if (curToken.type != LBRA) {
		error(MISSING_LEFT_BRACE, lexer.lineNum);
	}
	getToken();
	compState();
	if (curToken.type != RBRA) {
		error(MISSING_LEFT_BRACE, lexer.lineNum);
	}

	cout << setw(4) << left << lexer.lineNum<< "This is main function" << endl;
}

/*
<整数>        ::= ［＋｜－］<无符号整数>
*/
void Parser::intNum() {
	if (curToken.type == PLUS || curToken.type == MINUS) {
		getToken();
	}
	if (curToken.type == NUM) {
		getToken();
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}
	//cout << setw(4) << left << lexer.lineNum<< "This is a integer" << endl;
}

/*
<表达式>    ::= ［＋｜－］<项>{<加法运算符><项>}  
//[+|-]只作用于第一个<项>
*/
void Parser::expression() {
	if (curToken.type == PLUS || curToken.type == MINUS) {
		getToken();
	}
	item();
	while (curToken.type == PLUS || curToken.type == MINUS) {
		getToken();
		item();
	}
	
	cout << setw(4) << left << lexer.lineNum<< "This is an expression" << endl;
}

/*
<项>     ::= <因子>{<乘法运算符><因子>}
*/
void Parser::item() {
	factor();
	while (curToken.type == MULT || curToken.type == DIV) {
		getToken();
		factor();
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a item" << endl;
}

/*
<因子>    ::= <标识符>｜<标识符>‘[’<表达式>‘]’｜<整数>|<字符>｜<有返回值函数调用语句>|‘(’<表达式>‘)’
*/
void Parser::factor() {
	//<标识符>｜<标识符>‘[’<表达式>‘]’|<有返回值函数调用语句>
	string name;
	if (curToken.type == ID) { //***待修改
		pushToken(curToken);

		name = curToken.str;

		getToken();
		if (curToken.type == LBRK) {		//<标识符>‘[’<表达式>‘]’
			clearToken();
			getToken();
			expression();
			if (curToken.type == RBRK) {
				getToken();
			}
			else {
				error(MISSING_RIGHT_BRACKET, lexer.lineNum);
			}
		}
		else if (curToken.type == LPAR) {	//<有返回值函数调用语句>有参数
			pushToken(curToken);
			retract();
			getToken();
			funcWithValState();
		}
		else if (symTab.isFunc(name, INTTP) || symTab.isFunc(name, CHARTP)) {	//<有返回值函数调用语句>无参数，如果是函数，还需要回溯
			pushToken(curToken);
			retract();
			getToken();
			funcWithValState();
		}
		else {					//<标识符>
			clearToken();
			//getToken();
		}

	}
	//整数
	else if (curToken.type == PLUS || curToken.type == MINUS || curToken.type == NUM) {
		intNum();
	}
	else if (curToken.type == SIGCHAR) {
		getToken();
	}
	else if (curToken.type == LPAR) {
		getToken();
		expression();
		if (curToken.type == RPAR) {
			getToken();
		}
		else {
			error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
		}
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a factor" << endl;
}

/*
<参数表>    ::=  <类型标识符><标识符>{,<类型标识符><标识符>}
*/
void Parser::paraTab() {
	if (curToken.type == INT || curToken.type == CHAR) {
		getToken();
		if (curToken.type == ID) {
			getToken();
		}
		else {
			error(MISSING_IDEN, lexer.lineNum);
		}
	}
	while (curToken.type == COMMA) {
		getToken();
		if (curToken.type == INT || curToken.type == CHAR) {
			getToken();
			if (curToken.type == ID) {
				getToken();
			}
			else {
				error(MISSING_IDEN, lexer.lineNum);
			}
		}
		else {
			error(UNKNOWN, lexer.lineNum);
		}
	}

	cout << setw(4) << left << lexer.lineNum<< "This is a parameters table" << endl;
}

/*
<复合语句>   ::=  ［<常量说明>］［<变量说明>］<语句列>
<常量说明> first = {const}
<变量说明> first = {int, char}
<语句列> first = {if, do, {, switch, id, scanf, printf, ;, return}
*/
void Parser::compState() {
	if (curToken.type == CONST) {
		constDecl();
	}
	if (curToken.type == INT || curToken.type == CHAR) {
		varDecl();
	}
	if (curToken.type == IF || curToken.type == DO || curToken.type == LBRA || curToken.type == SWITCH ||
		curToken.type == ID || curToken.type == SCANF || curToken.type == PRINTF ||
		curToken.type == SEMI || curToken.type == RETURN) {
		stateCol();
	}
 	else if (curToken.type == RBRA) {
		//语句列为空
	}
	else {
		error(UNKNOWN, lexer.lineNum);
	}
	cout << setw(4) << left << lexer.lineNum<< "This is a compound statement" << endl;
}

/*
<语句列>   ::=｛<语句>｝
*/
void Parser::stateCol() {
	while (curToken.type == IF || curToken.type == DO || curToken.type == LBRA || curToken.type == SWITCH ||
		curToken.type == ID || curToken.type == SCANF || curToken.type == PRINTF ||
		curToken.type == SEMI || curToken.type == RETURN) {
		statement();
	}
	cout << setw(4) << left << lexer.lineNum<< "This is a statement column" << endl;
}

/*
<语句>    ::= <条件语句>｜<循环语句>| ‘{’<语句列>‘}’｜<情况语句>|<有返回值函数调用语句>;
					  |<无返回值函数调用语句>;｜<赋值语句>;｜<读语句>;｜<写语句>;｜<空>;｜<返回语句>;
<条件语句> first = {if}
<循环语句> first = {do}
‘{’<语句列>‘}’first = {'{'}
<情况语句> first = {switch}
<有返回值函数调用语句> first = {标识符}
<无返回值函数调用语句> first = {标识符}
<赋值语句> first = {标识符}
<读语句> first = {scanf}
<写语句> first = {printf}
<空>; first = {;}
<返回语句> first = {return}
*/
void Parser::statement() {
	string name;
	switch (curToken.type) {
	case IF:
		ifState();
		break;
	case DO:
		whileState();
		break;
	case SWITCH:
		switchState();
		break;
	case LBRA:
		getToken();
		stateCol();
		if (curToken.type != RBRA) {
			error(MISSING_RIGHT_BRACE, lexer.lineNum);
		}
		getToken();
		break;
	case ID:	//函数调用或赋值
		name = curToken.str;
		pushToken(curToken);
		getToken();

		if (curToken.type == LPAR) {	//函数调用有参数，待修改
			pushToken(curToken);
			retract();
			getToken();
			if (symTab.isFunc(name, VOIDTP))
				funcWithNoValState();
			else
				funcWithValState();
		}
		else {
			//赋值或有无返回值无参数函数调用语句，待修改*****
			pushToken(curToken);
			retract();
			getToken();
			if (symTab.isFunc(name, VOIDTP))
				funcWithNoValState();
			else if (symTab.isFunc(name, INTTP) || symTab.isFunc(name, CHARTP))
				funcWithValState();
			else
				assignState();
		}
		if (curToken.type != SEMI) {
			error(MISSING_SEMI, lexer.lineNum);
		}
		getToken();
		break;
	case SCANF:
		scanfState();
		if (curToken.type != SEMI) {
			error(MISSING_SEMI, lexer.lineNum);
		}
		getToken();
		break;
	case PRINTF:
		printfState();
		if (curToken.type != SEMI) {
			error(MISSING_SEMI, lexer.lineNum);
		}
		getToken();
		break;
	case SEMI:
		if (curToken.type != SEMI) {
			error(MISSING_SEMI, lexer.lineNum);
		}
		getToken();
		break;
	case RETURN:
		returnState();
		if (curToken.type != SEMI) {
			error(MISSING_SEMI, lexer.lineNum);
		}
		getToken();
		break;
	default:
		error(UNKNOWN, lexer.lineNum);
		break;
	}
}

/*
<条件语句>  ::=  if ‘(’<条件>‘)’<语句>else <语句>
*/
void Parser::ifState() {
	if (curToken.type != IF) {
		error(UNKNOWN, lexer.lineNum);
	}
	getToken();
	if (curToken.type != LPAR) {
		error(MISSING_LEFT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	condition();
	if (curToken.type != RPAR) {
		error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	statement();
	if (curToken.type != ELSE) {
		error(MISSING_ELSE, lexer.lineNum);
	}
	getToken();
	statement();

	cout << setw(4) << left << lexer.lineNum<< "This is a if statement" << endl;
}

/*
<条件>    ::=  <表达式><关系运算符><表达式>｜<表达式> //表达式为0条件为假，否则为真
*/
void Parser::condition() {
	expression();
	if (curToken.type == LSS || curToken.type == LEQ || curToken.type == GTR ||
		curToken.type == GEQ || curToken.type == NEQ || curToken.type == EQEQ) {
		getToken();
		expression();
	}

 	cout << setw(4) << left << lexer.lineNum<< "This is a condition" << endl;
}

/*
<循环语句>   ::=  do<语句>while ‘(’<条件>‘)’
*/
void Parser::whileState() {
	if (curToken.type != DO) {
		error(UNKNOWN, lexer.lineNum);
	}
	getToken();
	statement();
	if (curToken.type != WHILE) {
		error(MISSING_WHIL, lexer.lineNum);
	}
	getToken();
	if (curToken.type != LPAR) {
		error(MISSING_LEFT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	condition();
	if (curToken.type != RPAR) {
		error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	
	cout << setw(4) << left << lexer.lineNum<< "This is a while statement" << endl;
}

/*
<情况语句>  ::=  switch ‘(’<表达式>‘)’ ‘{’<情况表><缺省> ‘}’
<情况表>   ::=  <情况子语句>{<情况子语句>}
<缺省>   ::=  default : <语句>
*/
void Parser::switchState() {
	if (curToken.type != SWITCH) {
		error(UNKNOWN, lexer.lineNum);
	}
	getToken();
	if (curToken.type != LPAR) {
		error(MISSING_LEFT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	expression();
	if (curToken.type != RPAR) {
		error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	//情况表
	if (curToken.type == LBRA) {
		getToken();
		while (curToken.type == CASE) {
			caseState();
		}
		if (curToken.type != DEFAULT) {
			error(UNKNOWN, lexer.lineNum);
		}
		getToken();
		if (curToken.type != COLON) {
			error(MISSING_COLO, lexer.lineNum);
		}
		getToken();
		statement();
		if (curToken.type != RBRA) {
			error(MISSING_RIGHT_BRACE, lexer.lineNum);
		}
		else {
			getToken();
		}
	}
	cout << setw(4) << left << lexer.lineNum<< "This is a switch statement" << endl;
}

/*
<情况子语句>  ::=  case<常量>：<语句>
<常量>   ::=  <整数>|<字符>
*/
void Parser::caseState() {
	if (curToken.type == CASE) {
		getToken();
		if (curToken.type == SIGCHAR) {
			getToken();
		}
		else {
			intNum();
		}

		if (curToken.type == COLON) {
			getToken();
			statement();
		}
		else {
			error(MISSING_COLO, lexer.lineNum);
		}
	}
}

/*
<有返回值函数调用语句> ::= <标识符>‘(’<值参数表>‘)’|<标识符> //第一种选择为有参数的情况，第二种选择为无参数的情况
*/
void Parser::funcWithValState() {
	if (curToken.type != ID) {
		error(MISSING_IDEN, lexer.lineNum);
	}
	getToken();
	if (curToken.type == LPAR) {
		getToken();
		valParaTab();
		if (curToken.type == RPAR) {
			getToken();
		}
		else {
			error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
		}
	}
	cout << setw(4) << left << lexer.lineNum<< "This is a function call statement with return value " << endl;
}

/*
<无返回值函数调用语句> ::= <标识符>‘(’<值参数表>‘)’|<标识符> //第一种选择为有参数的情况，第二种选择为无参数的情况
*/
void Parser::funcWithNoValState() {
	if (curToken.type != ID) {
		error(MISSING_IDEN, lexer.lineNum);
	}
	getToken();
	if (curToken.type == LPAR) {
		getToken();
		valParaTab();
		if (curToken.type == RPAR) {
			getToken();
		}
		else {
			error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
		}
	}
	cout << setw(4) << left << lexer.lineNum<< "This is a function call statement without return value " << endl;
}

/*
<值参数表>   ::= <表达式>{,<表达式>}
*/
void Parser::valParaTab() {
	expression();
	while (curToken.type == COMMA) {
		getToken();
		expression();
	}
	
	cout << setw(4) << left << lexer.lineNum<< "This is a value parameter table" << endl;
}

/*
<赋值语句>   ::=  <标识符>＝<表达式>|<标识符>‘[’<表达式>‘]’=<表达式>
*/
void Parser::assignState() {
	if (curToken.type != ID) {
		error(MISSING_IDEN, lexer.lineNum);
	}
	getToken();
	if (curToken.type == EQU) {
		getToken();
		expression();
	}
	else if (curToken.type == LBRK) {
		getToken();
		expression();
		if (curToken.type != RBRK) {
			error(MISSING_RIGHT_BRACKET, lexer.lineNum);
		}
		getToken();
		if (curToken.type != EQU) {
			error(MISSING_EQUAL_SIGN, lexer.lineNum);
		}
		getToken();
		expression();
	}
	else {
		error(0, lexer.lineNum);
	}
	
	cout << setw(4) << left << lexer.lineNum<< "This is a assign statement" << endl;
}

/*
<读语句>    ::=  scanf ‘(’<标识符>{,<标识符>}‘)’
*/
void Parser::scanfState() {
	if (curToken.type != SCANF) {
		error(UNKNOWN, lexer.lineNum);
	}
	getToken();
	if (curToken.type != LPAR) {
		error(MISSING_LEFT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	if (curToken.type != ID) {
		error(MISSING_IDEN, lexer.lineNum);
	}
	getToken();
	while (curToken.type == COMMA) {
		getToken();
		if (curToken.type == ID) {
			getToken();
		}
		else {
			error(MISSING_IDEN, lexer.lineNum);
		}
	}
	if (curToken.type != RPAR) {
		error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
	}
	getToken();

	cout << setw(4) << left << lexer.lineNum<< "This is a scanf statement" << endl;
}

/*
<写语句>    ::=  printf‘(’<字符串>,<表达式>‘)’|printf ‘(’<字符串>‘)’|printf ‘(’<表达式>‘)’
*/
void Parser::printfState() {
	if (curToken.type != PRINTF) {
		error(UNKNOWN, lexer.lineNum);
	}
	getToken();
	if (curToken.type != LPAR) {
		error(MISSING_LEFT_PARENTHESIS, lexer.lineNum);
	}
	getToken();
	if (curToken.type == STRING) {
		getToken();
		if (curToken.type == COMMA) {
			getToken();
			expression();
		}
	}
	else {
		expression();
	}

	if (curToken.type != RPAR) {
		error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
	}
	getToken();

	cout << setw(4) << left << lexer.lineNum<< "This is a printf statement" << endl;
}

/*
<返回语句>   ::=  return[‘(’<表达式>‘)’]
*/
void Parser::returnState() {
	if (curToken.type != RETURN) {
		error(MISSING_RETU, lexer.lineNum);
	}
	getToken();
	if (curToken.type == LPAR) {
		getToken();
		expression();
		if (curToken.type == RPAR) {
			getToken();
		}
		else {
			error(MISSING_RIGHT_PARENTHESIS, lexer.lineNum);
		}
	}

	cout << setw(4) << left << lexer.lineNum  << "This is a return statement" << endl;
}

void parser_test() {
	Parser parser;
	string path;
	//path = "./in/in3.c";
	cin >> path;
	if (_access(path.data(), 0) == -1) {
		cout << "File doesn't exist!" << endl;
		return;
	}
	parser.lexer.fin.open(path, ios::in | ios::binary);
	parser.lexer.fout.open("./out/out.txt");
	parser.program();
	if (parser.lexer.ecount > 1)
		cout << "Compile failed!" << endl;
	else
		cout << "Compiled successfully" << endl;
}